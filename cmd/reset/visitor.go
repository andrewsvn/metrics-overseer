package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"text/template"

	"golang.org/x/tools/go/packages"
)

const (
	resettableStructComment string = "// generate:reset"
)

type ResettableStructData struct {
	Name            string
	FieldResetExprs []string
}

type PackageVisitor struct {
	PkgID     string
	PkgName   string
	PkgDir    string
	TypesInfo *types.Info
	Structs   []*ResettableStructData
}

const (
	resetMethodsFilename string = "reset.gen.go"
	resetStructIdent     string = "s"
	resetTemplateStr     string = `
// Code generated by go generate; DO NOT EDIT.
// This file was generated by reset tool

package {{.PkgName}}

{{range .Structs}}
func (s *{{.Name}}) Reset() {
	if s == nil {
		return
	}
	{{range .FieldResetExprs}}
    {{.}}{{end}}
}

{{end}}
`
)

func NewPackageVisitor(pkg *packages.Package) *PackageVisitor {
	return &PackageVisitor{
		PkgID:     pkg.ID,
		PkgName:   pkg.Name,
		PkgDir:    pkg.Dir,
		TypesInfo: pkg.TypesInfo,
	}
}

func ProcessPackage(pkg *packages.Package) error {
	visitor := NewPackageVisitor(pkg)
	for _, file := range pkg.Syntax {
		for _, decl := range file.Decls {
			ast.Inspect(decl, visitor.InspectDecl)
		}
	}
	return visitor.GenerateResetMethodsFile()
}

func (v *PackageVisitor) InspectDecl(node ast.Node) bool {
	genDecl, ok := node.(*ast.GenDecl)
	if !ok {
		return false
	}

	if structData := v.getResettableStructFromDecl(genDecl); structData != nil {
		log.Printf("Package %s: found resettable struct type %s", v.PkgID, structData.Name)
		v.Structs = append(v.Structs, structData)
	}
	return false
}

func (v *PackageVisitor) GenerateResetMethodsFile() error {
	if len(v.Structs) == 0 {
		return nil
	}

	log.Printf("Generating reset methods file for package %s", v.PkgID)
	log.Printf("Number of structs: %d", len(v.Structs))

	var buf bytes.Buffer
	resetTemplate := template.Must(template.New("resets").Parse(resetTemplateStr))
	err := resetTemplate.Execute(&buf, v)
	if err != nil {
		return fmt.Errorf("error instantiating reset package template: %w", err)
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("error formatting generated reset package template: %w", err)
	}

	wd, _ := os.Getwd()
	fname := filepath.Join(v.PkgDir, resetMethodsFilename)
	log.Printf("Workdir: %s, writing reset.gen.go file to: %s", wd, fname)
	err = os.WriteFile(fname, src, 0644)
	if err != nil {
		return fmt.Errorf("error writing reset.gen.go file: %w", err)
	}

	return nil
}

func (v *PackageVisitor) getResettableStructFromDecl(decl *ast.GenDecl) *ResettableStructData {
	if decl.Tok != token.TYPE {
		return nil
	}

	if !declHasResetComment(decl) {
		return nil
	}

	for _, spec := range decl.Specs {
		typeSpec, ok := spec.(*ast.TypeSpec)
		if !ok {
			continue
		}
		structType, ok := typeSpec.Type.(*ast.StructType)
		if !ok {
			continue
		}

		resetExprs := make([]string, 0, len(structType.Fields.List))
		for _, field := range structType.Fields.List {
			resetExprs = append(resetExprs, v.generateResetExprForField(field))
		}

		structData := &ResettableStructData{
			Name:            typeSpec.Name.Name,
			FieldResetExprs: resetExprs,
		}
		return structData
	}

	return nil
}

func declHasResetComment(decl *ast.GenDecl) bool {
	if decl.Doc == nil {
		return false
	}
	for _, comment := range decl.Doc.List {
		if comment.Text == resettableStructComment {
			return true
		}
	}
	return false
}

func (v *PackageVisitor) generateResetExprForField(field *ast.Field) string {
	name := field.Names[0].Name
	typ := v.TypesInfo.TypeOf(field.Type)
	return v.generateResetExpr(name, typ, "")
}

func (v *PackageVisitor) generateResetExpr(name string, typ types.Type, prefix string) string {
	switch t := typ.(type) {
	case *types.Basic:
		switch t.Kind() {
		case types.Bool:
			return fmt.Sprintf("%s%s.%s = false", prefix, resetStructIdent, name)
		case types.String:
			return fmt.Sprintf("%s%s.%s = \"\"", prefix, resetStructIdent, name)
		default:
			return fmt.Sprintf("%s%s.%s = 0", prefix, resetStructIdent, name)
		}
	case *types.Slice:
		return fmt.Sprintf("%s%s.%s = %s.%s[:0]", prefix, resetStructIdent, name, resetStructIdent, name)
	case *types.Map:
		return fmt.Sprintf("clear(%s%s.%s)", prefix, resetStructIdent, name)
	case *types.Named:
		return fmt.Sprintf(
			"if resetter, ok := %s%s.%s.(interface{ Reset() }); ok && %s%s.%s != nil {\nresetter.Reset()\n}",
			prefix, resetStructIdent, name, prefix, resetStructIdent, name)
	case *types.Pointer:
		subExpr := v.generateResetExpr(name, t.Elem(), "*"+prefix)
		if subExpr != "" {
			return fmt.Sprintf("if %s%s.%s != nil {\n%s\n}", prefix, resetStructIdent, name, subExpr)
		}
	}
	return ""
}
